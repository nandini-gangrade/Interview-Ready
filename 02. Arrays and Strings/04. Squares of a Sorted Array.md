# üìå Squares of a Sorted Array

**Problem:**
Given a **sorted integer array `nums`**, return an array of the **squares of each number**, also **sorted**.

> **Hint:** Think about negative numbers! Squaring them can make them the largest numbers.

---

### Examples

```text
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: 
After squaring: [-4^2, -1^2, 0^2, 3^2, 10^2] = [16,1,0,9,100]
After sorting: [0,1,9,16,100]

Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
```

**Constraints:**

* 1 <= nums.length <= 10^4
* -10^4 <= nums[i] <= 10^4
* `nums` is **sorted in non-decreasing order**

**LeetCode Link:** [977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/)

---

## 0Ô∏è‚É£ Why Interviewers Ask This üòÖ

* Tests your **ability to exploit the properties of sorted arrays**
* Can **trap beginners**: squaring negatives makes them positive ‚Üí biggest numbers can come from the ends
* Tests if you can do **O(n) with two pointers** instead of trivial O(n log n) sorting
* Shows reasoning about **index manipulation + in-place thinking**

---

## 1Ô∏è‚É£ Brute Force Approach (Not Optimal)

* Square all numbers
* Sort the array

```python
nums_squared = [x**2 for x in nums]
nums_squared.sort()
```

* ‚úÖ Works
* ‚ùå Time complexity: O(n log n)
* ‚ùå Interviewers expect O(n) for sorted input

> ‚ÄúWait‚Äîthis works but it‚Äôs not what we want üòÖ‚Äù

---

## 2Ô∏è‚É£ Key Insight for O(n) Solution

* Array is **sorted**, but negatives can produce largest squares
* So the **largest square is either at the left or right end**
* We can **use two pointers from the ends** and fill a new array **from largest to smallest**

**Visual Example:**

```
nums = [-4, -1, 0, 3, 10]

left  = 0  -> -4
right = 4  -> 10

Compare squares:
|-4|^2 = 16
|10|^2 = 100

100 > 16 ‚Üí put 100 at last position of result array
move right pointer left

Next:
left=0 -> -4
right=3 -> 3

|-4|^2 = 16
|3|^2 = 9

16 > 9 ‚Üí put 16 next-to-last position
move left pointer right
...
```

---

## 3Ô∏è‚É£ Algorithm (Two Pointers)

1. Create a result array `res` of same length as `nums`
2. Initialize **two pointers**:

   * `left = 0`
   * `right = len(nums) - 1`
   * `pos = len(nums) - 1` ‚Üí position to fill in `res`
3. While `left <= right`:

   * Compare `abs(nums[left])` and `abs(nums[right])`
   * Put **larger square** in `res[pos]`
   * Move pointer (left++ if left bigger, right-- if right bigger)
   * pos--
4. Return `res`

---

## 4Ô∏è‚É£ Python Code

```python
def sorted_squares(nums):
    n = len(nums)
    res = [0] * n  # output array
    left, right = 0, n - 1
    pos = n - 1    # fill from end

    while left <= right:
        left_sq = nums[left] ** 2
        right_sq = nums[right] ** 2

        if left_sq > right_sq:
            res[pos] = left_sq
            left += 1
        else:
            res[pos] = right_sq
            right -= 1
        pos -= 1

    return res
```

---

### Example Run

```python
nums = [-4,-1,0,3,10]
print(sorted_squares(nums))
# Output: [0, 1, 9, 16, 100]
```

**Step Visualization:**

```
Initial: [-4,-1,0,3,10]
res = [0,0,0,0,0]

Step1: left_sq=16, right_sq=100 ‚Üí res[4]=100, move right
Step2: left_sq=16, right_sq=9  ‚Üí res[3]=16, move left
Step3: left_sq=1,  right_sq=9  ‚Üí res[2]=9, move right
Step4: left_sq=1,  right_sq=0  ‚Üí res[1]=1, move left
Step5: left_sq=0,  right_sq=0  ‚Üí res[0]=0, done
```

‚úÖ All squares sorted in **O(n)** time, **O(n) space** (for output)

---

## 5Ô∏è‚É£ Complexity Analysis

| Metric | Complexity |
| ------ | ---------- |
| Time   | O(n)       |
| Space  | O(n)       |

* **Time O(n):** Each element visited once
* **Space O(n):** For result array (output counts as extra space)

> Optional interview note: If **in-place modification** of nums allowed ‚Üí trickier but can also be done with two pointers.

---

## 6Ô∏è‚É£ Why This Works

* Because `nums` is **sorted**, the largest absolute values are at the edges
* Squaring preserves order **only if all numbers non-negative**
* Two pointers let us **fill the largest square first**, moving inwards ‚Üí no need to sort again

> ‚ÄúWait‚Äîit looks like we could just sort, but that‚Äôs O(n log n). Two pointers let us do O(n) üòé‚Äù

---

## 7Ô∏è‚É£ LeetCode Patterns & Similar Problems

| Problem                                 | Pattern      | Notes                       |
| --------------------------------------- | ------------ | --------------------------- |
| 977. Squares of a Sorted Array          | Two pointers | Must do O(n)                |
| 167. Two Sum II - Input Array Is Sorted | Two pointers | Sum instead of squares      |
| 11. Container With Most Water           | Two pointers | Start at edges, move inward |
| 345. Reverse Vowels of a String         | Two pointers | Conditional swap            |
| 125. Valid Palindrome                   | Two pointers | Opposite ends comparison    |

---

## 8Ô∏è‚É£ When & Where to Use This Technique (Interview Perspective)

* **Sorted array + operation that can invert order (like square)** ‚Üí think **edges first**
* **Pair sums** ‚Üí find pairs that satisfy sum
* **Palindrome check** ‚Üí compare characters from ends
* **Merging or comparing two arrays** ‚Üí pointer per array

> Key skill interviewers test: **can you leverage array properties without brute force sorting?**

---

## 9Ô∏è‚É£ Key Takeaways / One-line Recall

> Sorted array, operation changes order ‚Üí use **two pointers at edges, fill output from largest, move inward** ‚Üí O(n) time, O(n) space. Always explain **why edges first** and **why no sort needed**.
