
# ğŸ“Œ Reverse a String (In-Place)

*(Two Pointers Classic â€” MUST KNOW for interviews)*

---

## 0ï¸âƒ£ Problem Statement

> Write a function that reverses a string. The input is **given as an array of characters `s`**.
> You must **modify the array in-place** and use **O(1) extra memory**.

---

### Examples

```text
Input:  s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]

Input:  s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
```

---

### Constraints

* 1 <= s.length <= 10^5
* s[i] is a printable ASCII character

---

### Why this is asked in interviews ğŸ˜…

* Tests **two pointer manipulation**
* Checks **in-place operations** (O(1) extra space)
* Shows if you can reason about **indices and swapping**
* Subtle trap: if you try recursion, you **use extra stack space**, which might fail interview constraints for very long strings

---

## 1ï¸âƒ£ Key Insight

We want to reverse the array **without creating a new one**.

* If we could use extra memory â†’ trivial: `s[::-1]` in Python
* But **in-place O(1)** â†’ must **swap elements from both ends**

Visualize:

```
s = ["h","e","l","l","o"]

left = 0         right = 4
swap s[left] â†” s[right]
["o","e","l","l","h"]

left = 1         right = 3
swap s[left] â†” s[right]
["o","l","l","e","h"]

left = 2, right = 2 â†’ stop
```

âœ… Works! We stopped when pointers meet/cross.

---

### Important Interview Note

> Always mention **why pointers meet or cross is the stopping condition**.

* If `left < right` â†’ still elements to swap
* If `left >= right` â†’ done
* Interviewers will ask:

> â€œWhy not `left <= right`?â€
> Answer: swapping middle element with itself is harmless but unnecessary. Using `<` is cleaner.

---

## 2ï¸âƒ£ Algorithm (Step-by-step)

1. Initialize two pointers:

   * `left = 0`
   * `right = len(s) - 1`
2. While `left < right`:

   * Swap `s[left]` and `s[right]`
   * Move `left += 1`, `right -= 1`
3. Return (array is modified **in-place**)

---

## 3ï¸âƒ£ Python Code

```python
def reverse_string(s):
    left, right = 0, len(s) - 1

    while left < right:
        # Swap
        s[left], s[right] = s[right], s[left]
        # Move pointers
        left += 1
        right -= 1

    # The array is reversed in-place
    return s  # optional, just for testing
```

---

### Output Examples

```python
print(reverse_string(["h","e","l","l","o"]))
# ["o","l","l","e","h"]

print(reverse_string(["H","a","n","n","a","h"]))
# ["h","a","n","n","a","H"]
```

---

## 4ï¸âƒ£ Time & Space Complexity

| Metric | Complexity |
| ------ | ---------- |
| Time   | O(n)       |
| Space  | O(1)       |

**Why O(n)?**

* Each element is swapped **exactly once**
* Each swap â†’ O(1)

**Why O(1) space?**

* We only use two integer pointers
* No new array created
* âœ… Perfect for in-place constraint

---

## 5ï¸âƒ£ Visualization (Pointer Movement)

```
Example: ["h","e","l","l","o"]

Step 1: left=0, right=4 â†’ swap
["o","e","l","l","h"]

Step 2: left=1, right=3 â†’ swap
["o","l","l","e","h"]

Step 3: left=2, right=2 â†’ stop
```

> Notice: middle element (if length is odd) stays in place. No extra swap needed ğŸ˜

---

## 6ï¸âƒ£ Common Interview Mistakes

1. **Creating a new array** â†’ violates O(1) space
2. **Swapping wrong indices** â†’ off-by-one errors
3. **Infinite loop** â†’ forgot `left += 1`, `right -= 1`
4. **Using recursion blindly** â†’ adds stack frames â†’ O(n) extra space, may fail large input
5. **Stopping condition wrong** â†’ using `<=` for even-length arrays is unnecessary

---

## 7ï¸âƒ£ Where Two Pointers Shows Up in Interviews (WHY)

* Reversing strings/arrays (classic)
* Checking **palindrome**
* **Pair sums** / Two Sum problems
* **Sliding window** / substring checks
* **Merging sorted arrays**
* Detecting cycles in arrays/linked lists

> Interviewers love Two Pointers because it tests **pointer logic + in-place reasoning**.

---

## 8ï¸âƒ£ Must-Know LeetCode References

| Problem                | Concept                    |
| ---------------------- | -------------------------- |
| 344. Reverse String    | Classic reverse in-place   |
| 125. Valid Palindrome  | Two pointers opposite ends |
| 167. Two Sum II        | Sorted array, two pointers |
| 88. Merge Sorted Array | Two pointers, merge        |
| 345. Reverse Vowels    | Swap specific elements     |
| 541. Reverse String II | Partial in-place reversal  |

---

## 9ï¸âƒ£ Why This Problem Matters (Interview Perspective)

* Shows **attention to constraints** (`O(1)` space)
* Shows **correct pointer logic**
* Shows ability to **visualize index movement**
* Can easily extend to:

  * Palindrome checks
  * Sliding window reversals
  * Subarray reversals

> â€œWaitâ€”this looks right but itâ€™s not ğŸ˜…â€ moment:
> If you just did `s[::-1]` and returned it, you failed the space constraint. Interviewers love catching this subtle trap.

---

## ğŸ”Ÿ Key Takeaways / One-line Recall

> Reverse a string in-place â†’ use **two pointers at edges â†’ swap â†’ move inward â†’ stop when meet** â†’ O(n) time, O(1) space. Always explain why pointers move and stopping condition exists.
