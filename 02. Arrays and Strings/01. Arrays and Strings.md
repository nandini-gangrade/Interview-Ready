# Arrays and Strings

Before jumping into fancy algorithms, let‚Äôs talk about **arrays and strings**.
Not because they‚Äôre exciting ‚Äî but because **almost every interview problem touches them in some way**.

If you‚Äôre comfortable with arrays and strings, half the battle is already won.

---

## Why arrays and strings matter so much

In algorithm problems, **arrays (1D)** and **strings** are everywhere.

Why?

* They represent an **ordered collection of elements**
* Most real problems naturally map to sequences:

  * list of numbers
  * characters in a word
  * logs, timestamps, IDs, prices, scores, etc.

If an interviewer gives you an input, there‚Äôs a very high chance it‚Äôs:

* an array
* a string
* or both

So being *comfortable* with them isn‚Äôt optional ‚Äî it‚Äôs foundational.

---

## Arrays and strings are more similar than you think

Conceptually:

* An **array** = ordered group of elements
* A **string** = ordered group of characters

That‚Äôs it.

Most techniques you learn for arrays:

* indexing
* traversal
* two pointers
* sliding window

‚Ä¶also apply to strings with very small tweaks.

This is why interview prep often groups **arrays + strings together**.

---

## ‚ÄúArray‚Äù means different things in different languages (important)

Here‚Äôs where beginners often get confused.

### Python

* Uses **lists**
* Very flexible

```python
arr = []
arr.append(10)
arr.append("hello")
```

No size declaration. No type declaration. Very forgiving.

---

### C++ / Java

* Traditional arrays need:

  * fixed size
  * fixed data type
* But you usually use:

  * `vector` in C++
  * `ArrayList` in Java

These are **dynamic arrays**.

---

### Important clarification (interview context)

Technically:

* An **array** cannot be resized
* A **dynamic array / list** *can* be resized

But in interviews:

> When people say ‚Äúarray‚Äù, they almost always mean **dynamic array**

So from now on:

* We‚Äôll say **array**
* But we really mean **dynamic array / list**

No need to overcorrect interviewers on terminology ‚Äî just understand what‚Äôs happening under the hood.

---

## Strings: mutable vs immutable (this REALLY matters)

Different languages treat strings differently.

* **Python & Java** ‚Üí strings are **immutable**
* **C++** ‚Üí strings are **mutable**

### What does that mean?

* **Mutable** ‚Üí you can change it in place
* **Immutable** ‚Üí you cannot change it after creation

---

### Simple example

```text
arr = ["a", "b", "c"]
s   = "abc"
```

Now you want `"abd"`.

For the array:

```text
arr[2] = "d"   // easy
```

For the string:

```text
s[2] = "d"     // ‚ùå not allowed
```

But wait ‚Äî there‚Äôs a catch üòÖ
To change a string, you must **create a brand new string**.

---

## WHY immutability matters (this is interview gold)

With small strings, immutability feels harmless.

But imagine:

* string length = 100,000
* you want to change **one character**

What happens?

* A **new string of size n** is created
* Time cost ‚Üí **O(n)**
* Memory cost ‚Üí **O(n)**

So repeatedly modifying strings naively can:

* kill performance
* cause TLE (Time Limit Exceeded)
* increase memory usage

---

### Interviewer expectation

Interviewers expect you to know:

* Strings are immutable (in most languages)
* Frequent modifications ‚Üí expensive
* Better approach:

  * convert to character array
  * or build result incrementally

If you mention this casually, you already sound experienced.

---

## Why you should care about implementation details

Interviewers usually won‚Äôt ask:

> ‚ÄúIs string mutable in Java?‚Äù

But they *will* ask problems where:

* inefficient string operations lead to bad complexity

If you don‚Äôt understand mutability:

* your solution might be logically correct
* but inefficient
* and rejected

Understanding **why** things are slow is what separates:

* ‚ÄúI know syntax‚Äù
* from ‚ÄúI understand performance‚Äù

---

## Arrays and strings: operation costs (must-know)

You don‚Äôt need to memorize everything ‚Äî just understand the patterns.

### Access by index

```text
arr[i]
s[i]
```

* **Time:** O(1)
* WHY: direct memory access

---

### Traversal

```text
for each element
```

* **Time:** O(n)
* WHY: you touch every element once

---

### Appending to end (dynamic array)

> Appending to the end of a list is **amortized O(1)**

But wait ‚Äî what does that even mean? üòÖ

---

## Amortized O(1) ‚Äî explained simply

Dynamic arrays have a **capacity**.

When capacity is full:

* a bigger array is created
* elements are copied over
* old array is discarded

That resize step is **O(n)**.

BUT:

* resizing doesn‚Äôt happen every time
* it happens rarely

So when averaged over many appends:

* cost per append ‚âà constant

That‚Äôs why we say:

> **Appending is amortized O(1)**

---

### Interview tip

If asked:

> ‚ÄúWhy is append O(1) but sometimes expensive?‚Äù

A strong answer:

> ‚ÄúBecause dynamic arrays occasionally resize, which costs O(n), but amortized over many operations it‚Äôs O(1).‚Äù

Short, confident, correct.

---

## Common array & string patterns (interview lens)

You‚Äôll see these again and again:

### 1Ô∏è‚É£ Two pointers

**WHY**:

* ordered data
* reduce nested loops

**HOW**:

* left pointer
* right pointer

Used in:

* reversing arrays/strings
* palindromes
* sorted array problems

---

### 2Ô∏è‚É£ Sliding window

**WHY**:

* contiguous subarrays or substrings
* avoid recalculating everything

**HOW**:

* expand right
* shrink left

Used in:

* longest substring problems
* subarray sums
* frequency tracking

---

### 3Ô∏è‚É£ Frequency counting

**WHY**:

* characters or numbers repeat

**HOW**:

* hash map / array

Used in:

* anagrams
* duplicates
* character counts

---

## What interviewers almost always expect you to know (arrays & strings)

### Q1: What‚Äôs the time complexity of iterating an array?

**Answer**: O(n), because each element is visited once.

---

### Q2: Why is random access O(1)?

**Answer**: Arrays store elements in contiguous memory, allowing direct index-based access.

---

### Q3: Why can string modification be expensive?

**Answer**: Because strings are immutable in many languages, so modifications require creating a new string of size n.

---

### Q4: What‚Äôs the space complexity of creating a new string?

**Answer**: O(n), where n is the length of the string.

---

### Q5: When would you convert a string to a character array?

**Answer**: When frequent modifications are required to avoid repeated O(n) string creation.

---

## Where you‚Äôll actually use arrays and strings (WHY + HOW)

### 1Ô∏è‚É£ Input representation

**WHY**:

* Most data naturally comes as sequences

**HOW**:

* problem input is often arrays or strings

---

### 2Ô∏è‚É£ Intermediate storage

**WHY**:

* need to process, filter, or transform data

**HOW**:

* store results temporarily in arrays

---

### 3Ô∏è‚É£ Optimization problems

**WHY**:

* contiguous data allows efficient techniques

**HOW**:

* sliding window
* prefix sums
* two pointers

---

### 4Ô∏è‚É£ Almost every DSA problem üòÑ

Honestly:

* trees use arrays
* graphs use arrays
* DP uses arrays
* recursion often works over arrays

They‚Äôre unavoidable ‚Äî and that‚Äôs good news.

---

## Short recap ‚Äî what you should remember

* Arrays and strings are **ordered collections**
* Most interview problems use them
* ‚ÄúArray‚Äù usually means **dynamic array**
* Strings may be **immutable**
* Immutability affects performance
* Index access ‚Üí O(1)
* Traversal ‚Üí O(n)
* Append ‚Üí amortized O(1)
* Knowing **why** operations cost what they do is crucial
