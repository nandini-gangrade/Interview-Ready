# ğŸ“Œ TWO POINTERS (Arrays & Strings)

*(Interview-Critical Pattern â€” MUST KNOW)*

---

## 0ï¸âƒ£ Prerequisites (for beginners â€” donâ€™t skip)

Before touching Two Pointers, you **must** be comfortable with:

* Arrays / Strings indexing
  â†’ accessing `arr[i]`, `s[i]`
* While loops
* Understanding **sorted vs unsorted**
* Time complexity basics (`O(n)`, `O(nÂ²)`)

If these are shaky, Two Pointers will feel like magic.
Interviewers hate magic. They love **reasoning**.

---

## 1ï¸âƒ£ What is Two Pointers? (Plain English)

**Two Pointers = using TWO index variables to walk through data instead of one**

Instead of:

```text
i = 0 â†’ n-1
```

We use:

```text
left = something
right = something else
```

â€¦and move them **based on logic**, not blindly.

### Why interviewers love this pattern ğŸ’™

Because it tests:

* Logical thinking
* Ability to reduce `O(nÂ²)` â†’ `O(n)`
* Understanding of sorted data
* Space optimization (`O(1)`)

If you master Two Pointers, you unlock:

* Palindrome checks
* Pair-sum problems
* Merging sorted arrays
* Subsequence problems
* Sliding window (next level)
* Even parts of recursion + DP later

---

## 2ï¸âƒ£ Two Core Two-Pointer Patterns (VERY IMPORTANT)

### Pattern 1: **Opposite Ends â†’ Move Inward**

Used when:

* Checking pairs
* Comparing symmetric elements
* Array or string is accessed from both sides

```text
left  â†’â†’
â†â†  right
```

### Pattern 2: **Same Direction â†’ Different Speeds**

Used when:

* Matching subsequences
* Merging arrays
* Comparing two sequences

```text
i â†’â†’â†’
j â†’â†’â†’
```

âš ï¸ Interviewers WILL ask:

> â€œWhy did you choose this pointer strategy?â€

You must answer **WHY**, not just HOW.

---

# ğŸ”¥ Pattern 1: Opposite Ends

---

## Example 1: Palindrome Check

### Problem

> Given a string `s`, return `true` if itâ€™s a palindrome.

ğŸ“Œ **LeetCode**:
[https://leetcode.com/problems/valid-palindrome/](https://leetcode.com/problems/valid-palindrome/)

---

### Why Two Pointers?

Palindrome means:

* first == last
* second == second last
* and so onâ€¦

So naturally:

* One pointer from start
* One pointer from end

No extra memory. No reversing needed.

---

### Visualization

```
s = "racecar"

r a c e c a r
^             ^
left        right
```

---

### Algorithm (Step-by-step)

1. `left = 0`
2. `right = s.length - 1`
3. While `left < right`:

   * If `s[left] != s[right]` â†’ âŒ not palindrome
   * Move both pointers inward

---

### Code (Beginner-friendly)

```python
def is_palindrome(s):
    left = 0
    right = len(s) - 1

    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1

    return True
```

### Output

```text
is_palindrome("racecar") â†’ True
is_palindrome("hello")   â†’ False
```

---

### Time & Space

* â± Time: `O(n)`
* ğŸ§  Space: `O(1)`

---

### Interviewer Trap ğŸ˜…

> â€œWhy not reverse the string and compare?â€

**Answer:**

* Reversing costs extra memory
* Two pointers do it in-place with `O(1)` space

---

## Example 2: Two Sum in Sorted Array

ğŸ“Œ **LeetCode 167**
[https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

---

### Problem

> Given a **sorted** array, check if any two numbers sum to target.

---

### Brute Force (BAD âŒ)

* Try all pairs
* Time: `O(nÂ²)`
  Interviewers stop you here.

---

### Why Two Pointers Works (IMPORTANT INTERVIEW NOTE)

Because the array is **sorted**.

Let:

* `nums[left] = x`
* `nums[right] = y`

If:

* `x + y > target` â†’ decrease `y`
* `x + y < target` â†’ increase `x`

Why is this safe?

ğŸ‘‰ Because:

* Moving left forward **always increases** sum
* Moving right backward **always decreases** sum
* You are permanently eliminating impossible pairs

This is the **core insight interviewers want**.

---

### Visualization

```
[1, 2, 4, 6, 8, 9, 14, 15]
 L                          R
```

---

### Code

```python
def two_sum_sorted(nums, target):
    left = 0
    right = len(nums) - 1

    while left < right:
        curr_sum = nums[left] + nums[right]

        if curr_sum == target:
            return True
        elif curr_sum < target:
            left += 1
        else:
            right -= 1

    return False
```

---

### Output

```text
two_sum_sorted([1,2,4,6,8,9,14,15], 13) â†’ True
```

---

### Interview Question They Ask

> â€œExplain WHY this is `O(n)`.â€

**Answer:**

* Each pointer moves at most `n` times
* Never moves backward
* Total operations â‰¤ `n`

---

# ğŸ” Pattern 2: Same Direction Two Pointers

---

## Example 3: Merge Two Sorted Arrays

ğŸ“Œ **LeetCode 88**
[https://leetcode.com/problems/merge-sorted-array/](https://leetcode.com/problems/merge-sorted-array/)

---

### Why Two Pointers?

Instead of:

* Merge â†’ sort â†’ `O(n log n)`

We:

* Compare smallest remaining elements
* Build result in one pass â†’ `O(n)`

---

### Visualization

```
arr1: [1, 3, 5]
        ^
arr2: [2, 4, 6]
        ^
```

---

### Code

```python
def merge_sorted(arr1, arr2):
    i = j = 0
    result = []

    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1

    # Append leftovers
    while i < len(arr1):
        result.append(arr1[i])
        i += 1

    while j < len(arr2):
        result.append(arr2[j])
        j += 1

    return result
```

---

### Time & Space

* â± Time: `O(n + m)`
* ğŸ§  Space: `O(1)` extra (excluding output)

---

## Example 4: Is Subsequence

ğŸ“Œ **LeetCode 392**
[https://leetcode.com/problems/is-subsequence/](https://leetcode.com/problems/is-subsequence/)

---

### Problem

> Check if `s` is a subsequence of `t`.

---

### Why Two Pointers?

We:

* Try to match `s` characters in order
* Move forward in `t` regardless
* Move forward in `s` **only when matched**

---

### Visualization

```
s = "ace"
t = "abcde"

a b c d e
^
```

---

### Code

```python
def is_subsequence(s, t):
    i = j = 0

    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1

    return i == len(s)
```

---

### Interview Explanation (MUST SAY)

* Each character in `t` is checked once
* We never go backward
* Order is preserved naturally

---

## 5ï¸âƒ£ Where Interviewers Use Two Pointers (WHY)

### Common Areas:

* Arrays
* Strings
* Linked Lists
* Sliding Window
* Fast & Slow Pointer (cycle detection)

### Why everywhere?

Because Two Pointers:

* Reduce nested loops
* Improve performance
* Use constant space
* Are easy to reason about once mastered

---

## 6ï¸âƒ£ Interview Rapid-Fire Q&A (VERY IMPORTANT)

### Q1: When should you think of Two Pointers?

**Answer:**

* Sorted input
* Pair checking
* Subsequence matching
* Symmetric comparisons

---

### Q2: Can Two Pointers work on unsorted arrays?

**Answer:**

* Sometimes, but usually needs hashing
* Sorting may be required first (`O(n log n)`)

---

### Q3: Why not use recursion here?

**Answer:**

* Recursion adds call stack space
* Two pointers solve iteratively with `O(1)` space

---

## 7ï¸âƒ£ MUST-DO LeetCode for Two Pointers

| Problem                      | Concept           |
| ---------------------------- | ----------------- |
| 125. Valid Palindrome        | Opposite pointers |
| 167. Two Sum II              | Sorted logic      |
| 392. Is Subsequence          | Same direction    |
| 88. Merge Sorted Array       | Merge pattern     |
| 977. Squares of Sorted Array | Dual movement     |
| 344. Reverse String          | Pointer swap      |

---

## ğŸ”š Final Closing Notes (Read This Twice)

* Two pointers is not about syntax
* Itâ€™s about **eliminating impossible states**
* Interviewers care more about **WHY pointers move** than the code

If you can explain:

> â€œWhy moving this pointer makes sense and doesnâ€™t miss solutionsâ€

Youâ€™re already ahead of 80% candidates.
