# Recursion ‚Äî explained clearly (for beginners & SDE switchers)

If you already understand recursion deeply, you can skip this.
If recursion feels confusing, slippery, or like something you ‚Äúkind of get but can‚Äôt explain‚Äù ‚Äî this is for you.

---

## What recursion actually is (clear definition)

Recursion is a **problem-solving approach**.

In code, recursion means:

> A function solves a problem by **calling itself on a smaller version of the same problem**.

That last part is important:

* same problem
* smaller input

The opposite of recursion is **iteration**, where we use loops (`for`, `while`) to repeat work.

There‚Äôs a theoretical proof that:

* Any iterative solution can be written recursively
* Any recursive solution can be written iteratively

So recursion is not special ‚Äî it‚Äôs just a **different way of thinking**.

---

## Iteration vs recursion (same logic, different mindset)

Let‚Äôs print numbers from 1 to 10.

### Iterative version (loop-based thinking)

```java
for (int i = 1; i <= 10; i++) {
    print(i);
}
```

You explicitly control:

* start
* end
* movement (`i++`)

---

### Recursive version (problem-reduction thinking)

```text
function fn(i):
    print(i)
    fn(i + 1)
    return

fn(1)
```

Here you‚Äôre saying:

> ‚ÄúPrint the current number, then let the function handle the rest.‚Äù

You‚Äôre delegating work to **future calls**.

---

## Why the above recursion is broken

That code never stops.

Why?

* There is **no condition to stop calling itself**
* The function keeps calling itself forever
* The return statement is never reached

This leads to:

* infinite recursion
* stack overflow
* program crash

---

## Base case ‚Äî the single most important rule of recursion

Every recursive function **must have a base case**.

A **base case** answers:

> ‚ÄúWhen should the function stop calling itself?‚Äù

Fixed version:

```text
function fn(i):
    if i > 10:
        return

    print(i)
    fn(i + 1)
    return

fn(1)
```

Now recursion:

* moves forward until `i = 11`
* hits base case
* stops creating new calls
* starts returning back

---

## How recursion actually executes (step-by-step)

This is where most confusion comes from.

Let‚Äôs reduce output to 1‚Äì3 and add logging.

```text
function fn(i):
1.  if i > 3:
2.      return

3.  print(i)
4.  fn(i + 1)
5.  print("End of call where i =", i)
6.  return

fn(1)
```

### Output

```
1
2
3
End of call where i = 3
End of call where i = 2
End of call where i = 1
```

---

### What‚Äôs happening internally (WHY this order appears)

* `fn(1)` prints 1 ‚Üí waits for `fn(2)`
* `fn(2)` prints 2 ‚Üí waits for `fn(3)`
* `fn(3)` prints 3 ‚Üí waits for `fn(4)`
* `fn(4)` hits base case ‚Üí returns immediately

Now:

* `fn(3)` resumes ‚Üí prints ‚ÄúEnd 3‚Äù
* `fn(2)` resumes ‚Üí prints ‚ÄúEnd 2‚Äù
* `fn(1)` resumes ‚Üí prints ‚ÄúEnd 1‚Äù

üëâ **Calls go down**
üëâ **Returns come back up in reverse order**

This is exactly how the **call stack** works.

---

## Each recursive call has its own scope (WHY this matters)

Every recursive call:

* has its own copy of parameters
* has its own local variables

So when:

* `fn(1)` ‚Üí `i = 1`
* `fn(2)` ‚Üí `i = 2`
* `fn(3)` ‚Üí `i = 3`

All three `i` values exist **simultaneously**, but independently.

WHY this matters:

* Changing a variable in one call doesn‚Äôt affect others
* This isolation makes recursion safe and predictable

---

## Why printing numbers with recursion is useless

Let‚Äôs be honest:

* Printing numbers is easier with a loop
* Recursion adds unnecessary overhead

So why use recursion at all?

---

## Where recursion actually shines (core idea)

Recursion is powerful when:

> A problem can be broken into **smaller subproblems of the same type**, whose results can be combined.

This pattern shows up **everywhere** in interviews.

---

## Fibonacci ‚Äî the classic recursion example

Fibonacci sequence:

```
0, 1, 1, 2, 3, 5, 8, ...
```

Definition:

* `F(0) = 0`
* `F(1) = 1`
* `F(n) = F(n - 1) + F(n - 2)`

This is called a **recurrence relation**:

* the solution depends on smaller versions of itself

---

### Recursive Fibonacci code

```text
function F(n):
    if n <= 1:
        return n

    return F(n - 1) + F(n - 2)
```

---

### How recursion solves this (WHY it works)

If you want `F(100)`:

* by definition, you need `F(99)` and `F(98)`
* to get `F(99)`, you need `F(98)` and `F(97)`
* and so on‚Ä¶

You don‚Äôt manually calculate everything.
You **trust recursion** to solve smaller pieces correctly.

This trust is key to recursion thinking.

---

## üö® Important interview note (VERY IMPORTANT ‚Äî deep explanation)

### Why naive recursive Fibonacci is bad

Even though the code is correct, it‚Äôs inefficient.

WHY?

Because:

* The same subproblems are solved again and again

Example:

* `F(3)` calls `F(2)` and `F(1)`
* `F(2)` again calls `F(1)` and `F(0)`
* `F(1)` is recomputed multiple times

This creates:

* exponential time complexity ‚Üí `O(2^n)`
* massive redundancy
* slow execution

---

### How interviewers expect you to think

Interviewers **do not want just recursion**.
They want:

1. Correctness
2. Awareness of inefficiency
3. Optimization ideas

A strong answer sounds like:

> ‚ÄúThis recursive solution is conceptually clean, but it recomputes overlapping subproblems. We can optimize it using memoization or convert it to dynamic programming.‚Äù

That sentence alone separates beginners from SDEs.

---

### How to fix it (idea-level, not code-heavy)

* **Memoization**: store already computed results
* **Bottom-up DP**: compute iteratively using previous values

Recursion teaches structure.
DP fixes performance.

---

## Recursion + LeetCode (must-do problems)

Below are **patterns**, not just problems.

---

### 1Ô∏è‚É£ Simple recursion (base case + forward movement)

**Problem**: Fibonacci Number
[https://leetcode.com/problems/fibonacci-number/](https://leetcode.com/problems/fibonacci-number/)

**Concept**:

* Base case
* Self-call on smaller input

**Pattern**:

> ‚ÄúSolve n using n-1 (and maybe n-2)‚Äù

---

### 2Ô∏è‚É£ String recursion

**Problem**: Reverse String
[https://leetcode.com/problems/reverse-string/](https://leetcode.com/problems/reverse-string/)

**Concept**:

* Reduce string size each call

**Pattern**:

> ‚ÄúFix one character, recurse on rest‚Äù

---

### 3Ô∏è‚É£ Tree recursion (MOST IMPORTANT)

**Problem**: Maximum Depth of Binary Tree
[https://leetcode.com/problems/maximum-depth-of-binary-tree/](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

**WHY recursion fits**:

* Trees are recursive by definition
* Each node is the root of a smaller tree

**Pattern**:

> ‚ÄúAnswer for node = combine answers from children‚Äù

---

### 4Ô∏è‚É£ Structural recursion

**Problem**: Invert Binary Tree
[https://leetcode.com/problems/invert-binary-tree/](https://leetcode.com/problems/invert-binary-tree/)

**Pattern**:

> ‚ÄúDo work at current node, recurse left & right‚Äù

---

### 5Ô∏è‚É£ Backtracking recursion

**Problem**: Subsets
[https://leetcode.com/problems/subsets/](https://leetcode.com/problems/subsets/)

**WHY recursion**:

* Each decision branches into include/exclude
* Natural tree of choices

**Pattern**:

> ‚ÄúTry all possibilities, undo changes‚Äù

---

## What interviewers almost always ask about recursion (with answers)

### Q1: What is the base case?

**Answer**:
The condition where recursion stops and no further calls are made.

---

### Q2: What happens if there‚Äôs no base case?

**Answer**:
Infinite recursion leading to stack overflow.

---

### Q3: What is the time complexity?

**Answer**:
Depends on:

* number of recursive calls
* branching factor

Example:

* Fibonacci ‚Üí exponential
* Tree traversal ‚Üí O(n)

---

### Q4: What is the space complexity?

**Answer**:
Stack space = maximum depth of recursion.

Example:

* Tree depth ‚Üí O(h)
* Linear recursion ‚Üí O(n)

---

### Q5: Can this be done iteratively?

**Answer**:
Yes. Recursion uses the call stack; iteration uses an explicit stack.

---

### Q6: When should you avoid recursion?

**Answer**:
When recursion depth is large and may cause stack overflow, or when iteration is clearer and safer.

---

## Where you‚Äôll actually use recursion (WHY + HOW)

### 1Ô∏è‚É£ Trees and graphs

**WHY**:

* Naturally recursive structure

**HOW**:

* DFS, traversal, height, path problems

---

### 2Ô∏è‚É£ Divide and conquer

**WHY**:

* Problem splits cleanly into smaller parts

**HOW**:

* Merge sort, quick sort

---

### 3Ô∏è‚É£ Backtracking

**WHY**:

* Multiple choices at each step

**HOW**:

* Subsets, permutations, combinations

---

### 4Ô∏è‚É£ Dynamic programming (top-down)

**WHY**:

* Recurrence relations map directly to recursion

**HOW**:

* Memoized recursion

---

### 5Ô∏è‚É£ Parsing & expression evaluation

**WHY**:

* Nested structure

**HOW**:

* Evaluate expressions, syntax trees

---

## Final recap ‚Äî what to remember

* Recursion = function calling itself
* Needs a **base case**
* Calls go down, returns come back up
* Each call has its own scope
* Great for breaking problems into subproblems
* Stack space matters
* Naive recursion can be inefficient
* Interviewers care about **thinking, not memorization**
